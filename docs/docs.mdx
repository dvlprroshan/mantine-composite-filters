import { InstallScript } from './components/InstallScript/InstallScript';
import * as demos from './demos';

## Installation

<InstallScript packages="mantine-composite-filters" />

### Peer Dependencies

This package requires the following peer dependencies:

<InstallScript packages="@mantine/core @mantine/hooks @mantine/dates @mantine/notifications @tabler/icons-react" />

Make sure you have Mantine properly set up in your project. See [Mantine Getting Started](https://mantine.dev/getting-started/) for setup instructions.

**Required setup:**
- `MantineProvider` wrapping your app
- `Notifications` component for toast notifications
- Import `mantine-composite-filters/styles.css` in your app

```tsx
import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css';
import 'mantine-composite-filters/styles.css';

import { MantineProvider } from '@mantine/core';
import { Notifications } from '@mantine/notifications';

function App() {
  return (
    <MantineProvider>
      <Notifications />
      {/* Your app */}
    </MantineProvider>
  );
}
```

## Overview

Build powerful filter interfaces in minutes. `CompositeFiltersInput` brings LinkedIn-style composite filtering to your Mantine apps - complete with type-safe definitions, smart operators, presets, and full keyboard support.

**Why use this?**
- Type any field name to start filtering
- Smart operator selection based on data type
- Save filter combinations as reusable presets
- Full keyboard navigation for power users
- Flexible storage with localStorage default or custom adapters

## Quick Start

<Demo data={demos.usage} />

Three props to get started:

```tsx
<CompositeFiltersInput
  filters={filterDefinitions}  // What fields can be filtered
  value={activeFilters}        // Current filter state
  onChange={setActiveFilters}  // State updater
/>
```

## Interactive Playground

<Demo data={demos.configurator} />

## Filter Types

Seven built-in types cover most filtering needs:

<Demo data={demos.allFilterTypes} />

| Type | Use Case | Default Operators |
|------|----------|-------------------|
| `text` | Names, titles, descriptions | `contains` `starts_with` `ends_with` `=` |
| `email` | Email addresses (with validation) | `contains` `=` |
| `number` | Prices, quantities, scores | `=` `!=` `>` `<` `>=` `<=` |
| `select` | Status, category, single choice | `=` |
| `multi_select` | Tags, roles, multiple choices | `=` |
| `date` | Single date values | `=` `>` `<` `>=` `<=` |
| `date_range` | Date periods, ranges | `between` |

## Limiting Filters

Control complexity with `maxFilters`:

<Demo data={demos.withMaxFilters} />

## Layout Options

Two overflow modes for different UI needs:

<Demo data={demos.overflowModes} />

| Mode | Behavior | Best For |
|------|----------|----------|
| `scroll` | Horizontal scroll, input stays visible | Narrow containers, toolbars |
| `wrap` | Filters wrap to new lines | Wide containers, dashboards |

## Presets & History

Let users save and recall filter combinations:

<Demo data={demos.withPresets} />

Built-in features (all persisted to localStorage by default):
- **Save presets** - Click "Save as preset" to open a modal where you can name and store filter combinations
- **Favorites** - Star presets for quick access
- **History** - Auto-tracked recent filter combinations (last 10)

### Custom Save Preset Modal

You can provide your own modal for saving presets using the `renderSavePresetModal` prop:

```tsx
import { Modal, TextInput, Button, Stack } from '@mantine/core';
import { useState } from 'react';
import type { SavePresetModalProps } from 'mantine-composite-filters';

function MyCustomSaveModal({ opened, onClose, onSave, activeFilters }: SavePresetModalProps) {
  const [name, setName] = useState('');

  const handleSave = () => {
    if (name.trim()) {
      onSave(name.trim());
      setName('');
    }
  };

  return (
    <Modal opened={opened} onClose={onClose} title="Save Your Filters">
      <Stack>
        <TextInput
          label="Preset Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="My awesome filter preset"
        />
        <p>You're saving {activeFilters.length} filters</p>
        <Button onClick={handleSave}>Save Preset</Button>
      </Stack>
    </Modal>
  );
}

// Usage
<CompositeFiltersInput
  filters={filters}
  value={activeFilters}
  onChange={setActiveFilters}
  renderSavePresetModal={(props) => <MyCustomSaveModal {...props} />}
/>
```

The `SavePresetModalProps` includes:
- `opened` - Whether the modal should be visible
- `onClose` - Function to close the modal
- `onSave` - Function to call with the preset name when saving
- `activeFilters` - Current active filters being saved

## Custom Storage Adapters

Need to store presets on your server or use a different storage mechanism? Create custom storage adapters:

<Demo data={demos.customStorageAdapter} />

### StorageAdapter Interface

```tsx
interface StorageAdapter<T> {
  get: () => T | Promise<T>;
  set: (value: T) => void | Promise<void>;
  remove: () => void | Promise<void>;
}
```

### Built-in Adapters

The package exports `createLocalStorageAdapter` for creating localStorage adapters with proper Date serialization:

```tsx
import { createLocalStorageAdapter } from 'mantine-composite-filters';

const presetsAdapter = createLocalStorageAdapter<SavedFilterPreset[]>(
  'my-presets-key',
  [] // default value
);
```

### API Storage Example

Store presets on your server:

```tsx
import type { StorageAdapter, SavedFilterPreset } from 'mantine-composite-filters';

const apiPresetsAdapter: StorageAdapter<SavedFilterPreset[]> = {
  get: async () => {
    const response = await fetch('/api/filter-presets');
    return response.json();
  },
  set: async (presets) => {
    await fetch('/api/filter-presets', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(presets),
    });
  },
  remove: async () => {
    await fetch('/api/filter-presets', { method: 'DELETE' });
  },
};

<CompositeFiltersInput
  filters={filters}
  value={activeFilters}
  onChange={setActiveFilters}
  presetsStorageAdapter={apiPresetsAdapter}
  historyStorageAdapter={apiHistoryAdapter}
/>
```

### Using with Hooks Directly

```tsx
import { useFilterPresets, useFilterHistory } from 'mantine-composite-filters';

const { presets, savePreset } = useFilterPresets({
  storageAdapter: myCustomAdapter,
  onLoad: setActiveFilters,
});

const { history } = useFilterHistory(activeFilters, {
  storageAdapter: myHistoryAdapter,
});
```

## Styles API

`CompositeFiltersInput` supports [Styles API](https://mantine.dev/styles/styles-api/), you can add styles to any inner element of the component with `classNames` prop.

<Demo data={demos.stylesApi} />

## Styling Examples

Make it yours with `styles` or `classNames`:

<Demo data={demos.customStyling} />

### Inline Styles

```tsx
// Direct object
<CompositeFiltersInput
  styles={{
    container: { borderRadius: '12px', borderColor: 'blue' },
  }}
/>

// Theme-aware function
<CompositeFiltersInput
  styles={(theme) => ({
    container: { backgroundColor: theme.colors.gray[0] },
  })}
/>
```

### CSS Classes

```tsx
<CompositeFiltersInput classNames={{ container: 'my-filter' }} />
```

```css
.my-filter { border: 2px solid #228be6; }
.my-filter:focus-within { box-shadow: 0 0 0 2px rgba(34, 139, 230, 0.2); }
```

## Custom Pills

Replace default filter chips with your own creative designs:

<Demo data={demos.customPills} />

### Gradient Style

```tsx
renderPill={(filter, onRemove) => (
  <Badge
    variant="gradient"
    gradient={{ from: 'violet', to: 'grape' }}
    rightSection={<CloseButton size="xs" onClick={onRemove} />}
  >
    {filter.label}: {filter.displayValue}
  </Badge>
)}
```

### Outlined with Icon

```tsx
renderPill={(filter, onRemove) => (
  <Paper withBorder radius="xl" px="sm" py={4}>
    <Group gap={6}>
      <ThemeIcon size={18} radius="xl" variant="light">
        <IconFilter size={10} />
      </ThemeIcon>
      <Text size="xs">{filter.label}</Text>
      <Text size="xs" c="blue" fw={600}>{filter.displayValue}</Text>
      <CloseButton size="xs" onClick={onRemove} />
    </Group>
  </Paper>
)}
```

### Card Style with Color Accent

```tsx
renderPill={(filter, onRemove) => (
  <Paper 
    shadow="xs" 
    px="sm" 
    py={6}
    style={{ borderLeft: '3px solid var(--mantine-color-blue-5)' }}
  >
    <Text size="xs" c="dimmed">{filter.label}</Text>
    <Text size="sm" fw={600}>{filter.displayValue}</Text>
    <CloseButton size="xs" onClick={onRemove} />
  </Paper>
)}
```

## Keyboard Shortcuts

Power user? Navigate without touching your mouse:

<Demo data={demos.keyboardShortcuts} />

| Shortcut | Action |
|----------|--------|
| `Cmd/Ctrl + /` | Focus filter input |
| `Cmd/Ctrl + Backspace` | Clear all filters |
| `Enter` | Confirm value |
| `Escape` | Cancel input |
| `Backspace` | Remove last filter |

## In Action

See it work with real data filtering:

<Demo data={demos.simpleDataTable} />

## Pro Tips

**Inline Editing** - Click any part of an active filter to edit it directly (field, operator, or value).

**Extend the Menu** - Add your own actions:

```tsx
<CompositeFiltersInput
  customActions={[
    { id: 'export', label: 'Export', onClick: handleExport },
    { id: 'share', label: 'Share Link', onClick: handleShare },
  ]}
/>
```

**Isolate Storage** - Use `storageKeyPrefix` when you have multiple filter instances:

```tsx
<CompositeFiltersInput storageKeyPrefix="users-page" />
<CompositeFiltersInput storageKeyPrefix="orders-page" />
```

## API Reference

### FilterDefinition

```tsx
{
  key: string;           // Unique ID
  label: string;         // Display name
  type: FilterType;      // text | email | number | select | multi_select | date | date_range
  options?: { value: string; label: string }[];  // For select types
  operators?: FilterOperator[];                   // Override defaults
  placeholder?: string;
  icon?: ReactNode;
}
```

### ActiveFilter

```tsx
{
  id: string;            // Auto-generated
  key: string;           // Matches FilterDefinition.key
  label: string;
  type: FilterType;
  operator: FilterOperator;
  value: string | string[] | [Date, Date];
  displayValue: string;  // Formatted for display
}
```

## TypeScript

Fully typed. Import what you need:

```tsx
import type { 
  FilterDefinition, 
  ActiveFilter, 
  FilterType,
  FilterOperator,
  StorageAdapter,
  SavedFilterPreset,
  FilterHistory,
  SavePresetModalProps,
} from 'mantine-composite-filters';
```

## Tips

- **Debounce** - For large datasets, debounce the `onChange` before fetching
- **Server validation** - Always validate filter values server-side
- **Mobile UX** - Use `overflowMode="wrap"` on smaller screens
- **Unique keys** - Each filter definition needs a unique `key`
