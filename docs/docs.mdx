import { InstallScript } from './components/InstallScript/InstallScript';
import * as demos from './demos';

## Installation

<InstallScript packages="mantine-composite-filters" />

### Peer Dependencies

This package requires the following peer dependencies:

<InstallScript packages="@mantine/core @mantine/hooks @mantine/dates @mantine/notifications @tabler/icons-react" />

Make sure you have Mantine properly set up in your project. See [Mantine Getting Started](https://mantine.dev/getting-started/) for setup instructions.

**Required setup:**
- `MantineProvider` wrapping your app
- `Notifications` component for toast notifications
- Import `mantine-composite-filters/styles.css` in your app

```tsx
import '@mantine/core/styles.css';
import '@mantine/dates/styles.css';
import '@mantine/notifications/styles.css';
import 'mantine-composite-filters/styles.css';

import { MantineProvider } from '@mantine/core';
import { Notifications } from '@mantine/notifications';

function App() {
  return (
    <MantineProvider>
      <Notifications />
      {/* Your app */}
    </MantineProvider>
  );
}
```

## Overview

Build powerful filter interfaces in minutes. `CompositeFiltersInput` brings LinkedIn-style composite filtering to your Mantine apps - complete with type-safe definitions, smart operators, presets, and full keyboard support.

**Why use this?**
- Type any field name to start filtering
- Smart operator selection based on data type
- Save filter combinations as reusable presets
- Full keyboard navigation for power users
- Flexible storage with localStorage default or custom adapters

## Quick Start

<Demo data={demos.usage} />

Three props to get started:

```tsx
<CompositeFiltersInput
  filters={filterDefinitions}  // What fields can be filtered
  value={activeFilters}        // Current filter state
  onChange={setActiveFilters}  // State updater
/>
```

## Interactive Playground

<Demo data={demos.configurator} />

## Filter Types

Seven built-in types cover most filtering needs:

<Demo data={demos.allFilterTypes} />

| Type | Use Case | Default Operators |
|------|----------|-------------------|
| `text` | Names, titles, descriptions | `contains` `starts_with` `ends_with` `=` |
| `email` | Email addresses (with validation) | `contains` `=` |
| `number` | Prices, quantities, scores | `=` `!=` `>` `<` `>=` `<=` |
| `select` | Status, category, single choice | `=` |
| `multi_select` | Tags, roles, multiple choices | `=` |
| `date` | Single date values | `=` `>` `<` `>=` `<=` |
| `date_range` | Date periods, ranges | `between` |

## Limiting Filters

Control complexity with `maxFilters`:

<Demo data={demos.withMaxFilters} />

## Layout Options

Two overflow modes for different UI needs:

<Demo data={demos.overflowModes} />

| Mode | Behavior | Best For |
|------|----------|----------|
| `scroll` | Horizontal scroll, input stays visible | Narrow containers, toolbars |
| `wrap` | Filters wrap to new lines | Wide containers, dashboards |

## Presets & History

Let users save and recall filter combinations:

<Demo data={demos.withPresets} />

Built-in features (all persisted to localStorage by default):
- **Save presets** - Click "Save as preset" to open a modal where you can name and store filter combinations
- **Favorites** - Star presets for quick access
- **History** - Auto-tracked recent filter combinations (last 10)

### Custom Save Preset Modal

You can provide your own modal for saving presets using the `renderSavePresetModal` prop:

```tsx
import { Modal, TextInput, Button, Stack } from '@mantine/core';
import { useState } from 'react';
import type { SavePresetModalProps } from 'mantine-composite-filters';

function MyCustomSaveModal({ opened, onClose, onSave, activeFilters }: SavePresetModalProps) {
  const [name, setName] = useState('');

  const handleSave = () => {
    if (name.trim()) {
      onSave(name.trim());
      setName('');
    }
  };

  return (
    <Modal opened={opened} onClose={onClose} title="Save Your Filters">
      <Stack>
        <TextInput
          label="Preset Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="My awesome filter preset"
        />
        <p>You're saving {activeFilters.length} filters</p>
        <Button onClick={handleSave}>Save Preset</Button>
      </Stack>
    </Modal>
  );
}

// Usage
<CompositeFiltersInput
  filters={filters}
  value={activeFilters}
  onChange={setActiveFilters}
  renderSavePresetModal={(props) => <MyCustomSaveModal {...props} />}
/>
```

The `SavePresetModalProps` includes:
- `opened` - Whether the modal should be visible
- `onClose` - Function to close the modal
- `onSave` - Function to call with the preset name when saving
- `activeFilters` - Current active filters being saved

## Custom Storage Adapters

Need to store presets on your server or use a different storage mechanism? Create custom storage adapters:

<Demo data={demos.customStorageAdapter} />

### StorageAdapter Interface

```tsx
interface StorageAdapter<T> {
  get: () => T | Promise<T>;
  set: (value: T) => void | Promise<void>;
  remove: () => void | Promise<void>;
}
```

### Built-in Adapters

The package exports `createLocalStorageAdapter` for creating localStorage adapters with proper Date serialization:

```tsx
import { createLocalStorageAdapter } from 'mantine-composite-filters';

const presetsAdapter = createLocalStorageAdapter<SavedFilterPreset[]>(
  'my-presets-key',
  [] // default value
);
```

### API Storage Example

Store presets on your server:

```tsx
import type { StorageAdapter, SavedFilterPreset } from 'mantine-composite-filters';

const apiPresetsAdapter: StorageAdapter<SavedFilterPreset[]> = {
  get: async () => {
    const response = await fetch('/api/filter-presets');
    return response.json();
  },
  set: async (presets) => {
    await fetch('/api/filter-presets', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(presets),
    });
  },
  remove: async () => {
    await fetch('/api/filter-presets', { method: 'DELETE' });
  },
};

<CompositeFiltersInput
  filters={filters}
  value={activeFilters}
  onChange={setActiveFilters}
  presetsStorageAdapter={apiPresetsAdapter}
  historyStorageAdapter={apiHistoryAdapter}
/>
```

## useCompositeFilters Hook

The `useCompositeFilters` hook provides a complete state management solution for filters, presets, and history - all in one hook with 70+ helper functions.

<Demo data={demos.useCompositeFiltersDemo} />

### Basic Usage

```tsx
import { useCompositeFilters, CompositeFiltersInput } from 'mantine-composite-filters';

const filterDefinitions = [
  { key: 'status', label: 'Status', type: 'select', options: [...] },
  { key: 'name', label: 'Name', type: 'text' },
];

function MyComponent() {
  const {
    activeFilters,
    setActiveFilters,
    addFilterByKey,
    removeFilter,
    clearFilters,
    filtersCount,
    presets,
    savePreset,
    loadPreset,
    history,
  } = useCompositeFilters({
    filterDefinitions,
    initialFilters: [],
    onFiltersChange: (filters) => console.log('Filters changed:', filters),
  });

  return (
    <CompositeFiltersInput
      filters={filterDefinitions}
      value={activeFilters}
      onChange={setActiveFilters}
    />
  );
}
```

### Hook Options

```tsx
interface UseCompositeFiltersOptions {
  filterDefinitions: FilterDefinition[];
  initialFilters?: ActiveFilter[];
  onFiltersChange?: (filters: ActiveFilter[]) => void;
  storageKey?: string;
  storageAdapter?: StorageAdapter<ActiveFilter[]>;
  presetsStorageKey?: string;
  presetsStorageAdapter?: StorageAdapter<SavedFilterPreset[]>;
  historyStorageKey?: string;
  historyStorageAdapter?: StorageAdapter<FilterHistory[]>;
  maxHistory?: number;
  enableHistory?: boolean;
  enablePresets?: boolean;
}
```

### Available Functions

**Filter CRUD Operations:**
| Function | Description |
|----------|-------------|
| `addFilter(filter)` | Add a filter and return its ID |
| `addFilterByKey(key, operator, value, displayValue?)` | Add filter using definition key |
| `removeFilter(id)` | Remove filter by ID |
| `removeFilterByKey(key)` | Remove all filters with key |
| `removeFiltersByKeys(keys)` | Remove filters matching any key |
| `updateFilter(id, updates)` | Update filter properties |
| `updateFilterValue(id, value, displayValue?)` | Update just the value |
| `updateFilterOperator(id, operator)` | Update just the operator |
| `replaceFilter(id, newFilter)` | Replace entire filter |
| `clearFilters()` | Remove all filters |
| `resetFilters()` | Reset to initial filters |

**Filter Getters:**
| Function | Description |
|----------|-------------|
| `getFilterById(id)` | Get filter by ID |
| `getFilterByKey(key)` | Get first filter with key |
| `getFiltersByKey(key)` | Get all filters with key |
| `getFiltersByType(type)` | Get filters by type |
| `getFiltersByOperator(operator)` | Get filters by operator |
| `getFirstFilter()` | Get first filter |
| `getLastFilter()` | Get last filter |

**Filter Checks:**
| Function/Property | Description |
|----------|-------------|
| `hasFilter(key)` | Check if filter exists |
| `hasFilterById(id)` | Check by ID |
| `hasFilterWithValue(key, value)` | Check key + value combo |
| `hasAnyFilter()` | Any filters active? |
| `hasMultipleFilters()` | More than one filter? |
| `filtersCount` | Number of active filters |

**Reordering:**
| Function | Description |
|----------|-------------|
| `moveFilterUp(id)` | Move filter up |
| `moveFilterDown(id)` | Move filter down |
| `moveFilterToStart(id)` | Move to first position |
| `moveFilterToEnd(id)` | Move to last position |
| `swapFilters(id1, id2)` | Swap two filters |
| `reorderFilters(ids)` | Reorder by ID array |

**Utilities:**
| Function | Description |
|----------|-------------|
| `duplicateFilter(id)` | Clone a filter |
| `toggleFilter(key, operator, value)` | Add or remove filter |
| `upsertFilter(key, operator, value)` | Update or create filter |

**Serialization:**
| Function | Description |
|----------|-------------|
| `toQueryParams()` | Convert to URL params object |
| `toQueryString()` | Convert to URL query string |
| `toApiFormat()` | Convert to API-friendly format |
| `toJSON()` | Export as JSON string |
| `fromJSON(json)` | Import from JSON |
| `serialize()` | Base64 encode filters |
| `deserialize(data)` | Base64 decode filters |

**Presets:**
| Function/Property | Description |
|----------|-------------|
| `presets` | All saved presets |
| `sortedPresets` | Presets sorted by favorite |
| `favoritePresets` | Only favorite presets |
| `presetsCount` | Number of presets |
| `hasPresets` | Any presets saved? |
| `savePreset(name)` | Save current filters |
| `loadPreset(preset)` | Load a preset |
| `loadPresetById(id)` | Load preset by ID |
| `deletePreset(id)` | Delete a preset |
| `updatePreset(id, updates)` | Update preset |
| `renamePreset(id, newName)` | Rename preset |
| `togglePresetFavorite(id)` | Toggle favorite |
| `duplicatePreset(id, newName?)` | Clone preset |
| `overwritePreset(id)` | Overwrite with current |
| `getPresetById(id)` | Get preset by ID |
| `clearPresets()` | Delete all presets |

**History:**
| Function/Property | Description |
|----------|-------------|
| `history` | Full history array |
| `recentHistory` | Last 5 entries |
| `historyCount` | Number of entries |
| `hasHistory` | Any history? |
| `loadFromHistory(item)` | Load history item |
| `loadFromHistoryByIndex(index)` | Load by index |
| `clearHistory()` | Clear all history |
| `removeHistoryItem(timestamp)` | Remove entry |
| `undoToLastHistory()` | Undo to previous |

**Definitions:**
| Function | Description |
|----------|-------------|
| `getDefinition(key)` | Get filter definition |
| `getAvailableDefinitions()` | Unused definitions |
| `isDefinitionUsed(key)` | Is definition in use? |
| `canAddMoreFilters(max?)` | Can add more filters? |

**State Tracking:**
| Function/Property | Description |
|----------|-------------|
| `isDirty` | Filters changed from initial? |
| `markAsClean()` | Mark current state as clean |
| `hasUnsavedChanges()` | Same as isDirty |

### Examples

**Programmatic Filter Management:**

```tsx
const { addFilterByKey, removeFilterByKey, clearFilters } = useCompositeFilters({
  filterDefinitions,
});

// Add a filter programmatically
addFilterByKey('status', '=', 'active', 'Active');

// Remove all status filters
removeFilterByKey('status');

// Clear everything
clearFilters();
```

**URL Sync:**

```tsx
const { toQueryString, fromJSON, toJSON } = useCompositeFilters({
  filterDefinitions,
});

// Sync to URL
useEffect(() => {
  const params = toQueryString();
  window.history.replaceState({}, '', `?${params}`);
}, [toQueryString]);

// Share filters
const shareFilters = () => {
  const encoded = btoa(toJSON());
  navigator.clipboard.writeText(`${window.location.origin}?filters=${encoded}`);
};
```

**API Integration:**

```tsx
const { toApiFormat, activeFilters } = useCompositeFilters({
  filterDefinitions,
  onFiltersChange: (filters) => {
    // Debounce and fetch
    fetchData(toApiFormat());
  },
});
```

**Dirty State Tracking:**

```tsx
const { isDirty, markAsClean, resetFilters } = useCompositeFilters({
  filterDefinitions,
  initialFilters: savedFilters,
});

const handleSave = () => {
  saveToServer(activeFilters);
  markAsClean();
};

// Show unsaved changes warning
{isDirty && <Text c="yellow">You have unsaved changes</Text>}
```

### Using Individual Hooks

For more granular control, you can also use the individual hooks:

```tsx
import { useFilterPresets, useFilterHistory } from 'mantine-composite-filters';

const { presets, savePreset } = useFilterPresets({
  storageAdapter: myCustomAdapter,
  onLoad: setActiveFilters,
});

const { history } = useFilterHistory(activeFilters, {
  storageAdapter: myHistoryAdapter,
});
```

## Styles API

`CompositeFiltersInput` supports [Styles API](https://mantine.dev/styles/styles-api/), you can add styles to any inner element of the component with `classNames` prop.

<Demo data={demos.stylesApi} />

## Styling Examples

Make it yours with `styles` or `classNames`:

<Demo data={demos.customStyling} />

### Inline Styles

```tsx
// Direct object
<CompositeFiltersInput
  styles={{
    container: { borderRadius: '12px', borderColor: 'blue' },
  }}
/>

// Theme-aware function
<CompositeFiltersInput
  styles={(theme) => ({
    container: { backgroundColor: theme.colors.gray[0] },
  })}
/>
```

### CSS Classes

```tsx
<CompositeFiltersInput classNames={{ container: 'my-filter' }} />
```

```css
.my-filter { border: 2px solid #228be6; }
.my-filter:focus-within { box-shadow: 0 0 0 2px rgba(34, 139, 230, 0.2); }
```

## Custom Pills

Replace default filter chips with your own creative designs:

<Demo data={demos.customPills} />

### Gradient Style

```tsx
renderPill={(filter, onRemove) => (
  <Badge
    variant="gradient"
    gradient={{ from: 'violet', to: 'grape' }}
    rightSection={<CloseButton size="xs" onClick={onRemove} />}
  >
    {filter.label}: {filter.displayValue}
  </Badge>
)}
```

### Outlined with Icon

```tsx
renderPill={(filter, onRemove) => (
  <Paper withBorder radius="xl" px="sm" py={4}>
    <Group gap={6}>
      <ThemeIcon size={18} radius="xl" variant="light">
        <IconFilter size={10} />
      </ThemeIcon>
      <Text size="xs">{filter.label}</Text>
      <Text size="xs" c="blue" fw={600}>{filter.displayValue}</Text>
      <CloseButton size="xs" onClick={onRemove} />
    </Group>
  </Paper>
)}
```

### Card Style with Color Accent

```tsx
renderPill={(filter, onRemove) => (
  <Paper 
    shadow="xs" 
    px="sm" 
    py={6}
    style={{ borderLeft: '3px solid var(--mantine-color-blue-5)' }}
  >
    <Text size="xs" c="dimmed">{filter.label}</Text>
    <Text size="sm" fw={600}>{filter.displayValue}</Text>
    <CloseButton size="xs" onClick={onRemove} />
  </Paper>
)}
```

## Keyboard Shortcuts

Power user? Navigate without touching your mouse:

<Demo data={demos.keyboardShortcuts} />

| Shortcut | Action |
|----------|--------|
| `Cmd/Ctrl + /` | Focus filter input |
| `Cmd/Ctrl + Backspace` | Clear all filters |
| `Enter` | Confirm value |
| `Escape` | Cancel input |
| `Backspace` | Remove last filter |

## In Action

See it work with real data filtering:

<Demo data={demos.simpleDataTable} />

## Pro Tips

**Inline Editing** - Click any part of an active filter to edit it directly (field, operator, or value).

**Extend the Menu** - Add your own actions:

```tsx
<CompositeFiltersInput
  customActions={[
    { id: 'export', label: 'Export', onClick: handleExport },
    { id: 'share', label: 'Share Link', onClick: handleShare },
  ]}
/>
```

**Isolate Storage** - Use `storageKeyPrefix` when you have multiple filter instances:

```tsx
<CompositeFiltersInput storageKeyPrefix="users-page" />
<CompositeFiltersInput storageKeyPrefix="orders-page" />
```

## API Reference

### FilterDefinition

```tsx
{
  key: string;           // Unique ID
  label: string;         // Display name
  type: FilterType;      // text | email | number | select | multi_select | date | date_range
  options?: { value: string; label: string }[];  // For select types
  operators?: FilterOperator[];                   // Override defaults
  placeholder?: string;
  icon?: ReactNode;
}
```

### ActiveFilter

```tsx
{
  id: string;            // Auto-generated
  key: string;           // Matches FilterDefinition.key
  label: string;
  type: FilterType;
  operator: FilterOperator;
  value: string | string[] | [Date, Date];
  displayValue: string;  // Formatted for display
}
```

## TypeScript

Fully typed. Import what you need:

```tsx
import type { 
  FilterDefinition, 
  ActiveFilter, 
  FilterType,
  FilterOperator,
  FilterValue,
  StorageAdapter,
  SavedFilterPreset,
  FilterHistory,
  SavePresetModalProps,
  UseCompositeFiltersOptions,
  UseCompositeFiltersReturn,
} from 'mantine-composite-filters';
```

## Tips

- **Debounce** - For large datasets, debounce the `onChange` before fetching
- **Server validation** - Always validate filter values server-side
- **Mobile UX** - Use `overflowMode="wrap"` on smaller screens
- **Unique keys** - Each filter definition needs a unique `key`
